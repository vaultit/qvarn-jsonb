# Step implementations

This chapter shows the scenario step implementations.

## Start and stop Qvarn

Start a Qvarn running in the background.

    IMPLEMENTS GIVEN a running qvarn instance
    start_qvarn('default')

## Stop a Qvarn we started

    IMPLEMENTS FINALLY qvarn is stopped
    stop_qvarn('default')

## API requests of various kinds

    IMPLEMENTS WHEN client requests GET (/.+) without token
    path = get_next_match()
    path = expand_vars(path, vars)
    vars['status_code'], vars['headers'], vars['body'] = get(
        vars['default']['url'] + path)

    IMPLEMENTS WHEN client requests GET (/.+) using token
    path = get_next_match()
    path = expand_vars(path, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
    }
    vars['status_code'], vars['headers'], vars['body'] = get(
        vars['default']['url'] + path, headers)

    IMPLEMENTS WHEN client requests POST (/.+) with token and body (.+)
    path = get_next_match()
    body = get_next_match()
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Content-Type': 'application/json',
    }
    vars['status_code'], vars['headers'], vars['body'] = post(
        vars['default']['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/.+) with token and body (.+)
    path = get_next_match()
    path = expand_vars(path, vars)
    body = get_next_match()
    body = expand_vars(body, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Content-Type': 'application/json',
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['default']['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/[a-z0-9/${}]+) with token, revision (\S+), content-type (\S+), and empty body
    path = expand_vars(get_next_match(), vars)
    revision = expand_vars(get_next_match(), vars)
    ctype = expand_vars(get_next_match(), vars)
    body = ''
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Revision': revision,
        'Content-Type': ctype,
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['default']['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/[a-z0-9/${}]+) with token, revision (\S+), content-type (\S+), and body "(.+)"
    path = expand_vars(get_next_match(), vars)
    revision = expand_vars(get_next_match(), vars)
    ctype = expand_vars(get_next_match(), vars)
    body = unescape(expand_vars(get_next_match(), vars))
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Revision': revision,
        'Content-Type': ctype,
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['default']['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests DELETE (/.+) with token
    path = get_next_match()
    path = expand_vars(path, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
    }
    vars['status_code'], vars['headers'], vars['body'] = delete(
        vars['default']['url'] + path, headers=headers)

    IMPLEMENTS WHEN client uploads a fake jpg
    assert 0

## API access token creation

    IMPLEMENTS WHEN client gets an authorization token with scope "(.+)"
    scopes = get_next_match()
    privkey = vars['default']['privkey']
    iss = vars['default']['issuer']
    aud = vars['default']['audience']
    print 'privkey', repr(privkey)
    assert privkey
    vars['token'] = create_token(privkey, iss, aud, scopes)

## UUID creation

    IMPLEMENTS GIVEN unique random identifier (\S+)
    import uuid
    name = get_next_match()
    vars[name] = str(uuid.uuid4())

## API request result checking

    IMPLEMENTS THEN HTTP status code is (\d+) (.*)
    expected = int(get_next_match())
    assertEqual(vars['status_code'], expected)

    IMPLEMENTS THEN HTTP (\S+) header is (.+)
    header = get_next_match()
    vars['API_URL'] = vars['default']['url']
    value = expand_vars(get_next_match(), vars)
    assertEqual(vars['headers'].get(header), value)

    IMPLEMENTS THEN remember HTTP (\S+) header as (.+)
    header = get_next_match()
    name = get_next_match()
    vars[name] = vars['headers'].get(header)

    IMPLEMENTS THEN resource id is (\S+)
    import json
    name = get_next_match()
    print 'body:', repr(vars['body'])
    body = json.loads(vars['body'])
    vars[name] = body['id']

    IMPLEMENTS THEN revision is (\S+)
    import json
    name = get_next_match()
    body = json.loads(vars['body'])
    vars[name] = body['revision']

    IMPLEMENTS THEN revisions (\S+) and (\S+) are different
    rev1 = get_next_match()
    rev2 = get_next_match()
    assertNotEqual(vars[rev1], vars[rev2])

    IMPLEMENTS THEN revisions (\S+) and (\S+) match
    rev1 = get_next_match()
    rev2 = get_next_match()
    assertEqual(vars[rev1], vars[rev2])

    IMPLEMENTS THEN JSON body matches (.+)
    import json
    wanted = get_next_match()
    print 'wanted1', repr(wanted)
    wanted = expand_vars(wanted, vars)
    print 'wanted2', repr(wanted)
    wanted = json.loads(wanted)
    actual = json.loads(vars['body'])
    print 'actual ', repr(actual)
    print 'wanted3', repr(wanted)
    assertTrue(values_match(wanted, actual))

    IMPLEMENTS THEN body is "(.+)"
    wanted = unescape(expand_vars(get_next_match(), vars))
    body = vars['body']
    assertTrue(values_match(wanted, body))

    IMPLEMENTS THEN search result contains (.+)
    import json
    wanted1 = get_next_match()
    wanted2 = expand_vars(wanted1, vars)
    wanted = json.loads(wanted2)
    actual = json.loads(vars['body'])
    print 'wanted1:', repr(wanted1)
    print 'wanted2:', repr(wanted2)
    print 'wanted:', repr(wanted)
    print 'actual:', repr(actual)
    assertTrue(actual['resources'])
    found = False
    for result in actual['resources']:
        if values_match(wanted, result):
            print 'MATCH!', repr(wanted), repr(result)
            found = True
            break
        print 'no match', repr(wanted), repr(result)
    assertTrue(found)

    IMPLEMENTS THEN search result does NOT contain (.+)
    import json
    wanted1 = get_next_match()
    wanted2 = expand_vars(wanted1, vars)
    wanted = json.loads(wanted2)
    actual = json.loads(vars['body'])
    print 'wanted1:', repr(wanted1)
    print 'wanted2:', repr(wanted2)
    print 'wanted:', repr(wanted)
    print 'actual:', repr(actual)
    found = False
    for result in actual['resources']:
        if values_match(wanted, result):
            found = True
    assertFalse(found)

    IMPLEMENTS THEN search result at index (\d+) has id (\S+)
    import json
    index = int(get_next_match())
    id_name = get_next_match()
    body = json.loads(vars['body'])
    print 'body', repr(body)
    resources = body['resources']
    print 'resources', repr(resources)
    print 'len resources', len(resources)
    print 'index', index
    assert index < len(resources)
    obj = resources[index]
    print 'resource at index', repr(obj)
    print 'id', repr(obj['id'])
    vars[id_name] = obj['id']

    IMPLEMENTS THEN search result has (\d+) resources
    wanted = int(get_next_match())
    body = json.loads(vars['body'])
    print 'body', repr(body)
    resources = body['resources']
    print 'resources', repr(resources)
    print 'len resources', len(resources)
    assertEqual(wanted, len(resources))

    IMPLEMENTS THEN response has header WWW-Authenticate containing "(.+)"
    assert 0
