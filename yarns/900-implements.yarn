# Step implementations

This chapter shows the scenario step implementations.

## Start and stop Qvarn

Start a Qvarn running in the background.

    IMPLEMENTS GIVEN a running qvarn instance
    import os, time, cliapp, yaml, yarnutils
    privkey, pubkey = create_token_signing_key_pair()
    print repr(privkey)
    print repr(pubkey)
    assert privkey
    assert pubkey
    open('key', 'w').write(privkey)
    vars['aud'] = 'http://api.test.example.com'
    vars['iss'] = 'qvarn.yarn'
    vars['privkey'] = privkey
    vars['pubkey'] = pubkey
    vars['api.log'] = 'qvarn.log'
    vars['gunicorn3.log'] = 'gunicorn3.log'
    vars['pid-file'] = 'pid'
    vars['port'] = cliapp.runcmd([os.path.join(srcdir, 'randport' )]).strip()
    vars['url'] = 'http://127.0.0.1:{}'.format(vars['port'])
    vars['API_URL'] = vars['url']
    config = {
        'log': [
            {
                'filename': vars['api.log'],
            },
        ],
        'baseurl': vars['url'],
        'token-issuer': vars['iss'],
        'token-audience': vars['aud'],
        'token-public-key': vars['pubkey'],
        'resource-type-dir': os.path.join(srcdir, 'resource_type'),
    }
    config = add_postgres_config(config)
    env = dict(os.environ)
    env['QVARN_CONFIG'] = os.path.join(datadir, 'qvarn.yaml')
    yaml.safe_dump(config, open(env['QVARN_CONFIG'], 'w'))
    argv = [
        'gunicorn3',
        '--daemon',
        '--bind', '127.0.0.1:{}'.format(vars['port']),
        '-p', vars['pid-file'],
        'qvarn.backend:app',
    ]
    cliapp.runcmd(argv, env=env, stdout=None, stderr=None)
    until = time.time() + 2.0
    while time.time() < until and not os.path.exists(vars['pid-file']):
        time.sleep(0.01)
    assert os.path.exists(vars['pid-file'])

## Stop a Qvarn we started

    IMPLEMENTS FINALLY qvarn is stopped
    import os, signal, yarnutils
    pid = int(cat(vars['pid-file']))
    os.kill(pid, signal.SIGTERM)

## API requests of various kinds

    IMPLEMENTS WHEN client requests GET (/.+) without token
    path = get_next_match()
    path = expand_vars(path, vars)
    vars['status_code'], vars['headers'], vars['body'] = get(vars['url'] + path)

    IMPLEMENTS WHEN client requests GET (/.+) using token
    path = get_next_match()
    path = expand_vars(path, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
    }
    vars['status_code'], vars['headers'], vars['body'] = get(
        vars['url'] + path, headers)

    IMPLEMENTS WHEN client requests POST (/.+) with token and body (.+)
    path = get_next_match()
    body = get_next_match()
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Content-Type': 'application/json',
    }
    vars['status_code'], vars['headers'], vars['body'] = post(
        vars['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/.+) with token and body (.+)
    path = get_next_match()
    path = expand_vars(path, vars)
    body = get_next_match()
    body = expand_vars(body, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Content-Type': 'application/json',
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/[a-z0-9/${}]+) with token, revision (\S+), content-type (\S+), and empty body
    path = expand_vars(get_next_match(), vars)
    revision = expand_vars(get_next_match(), vars)
    ctype = expand_vars(get_next_match(), vars)
    body = ''
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Revision': revision,
        'Content-Type': ctype,
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests PUT (/[a-z0-9/${}]+) with token, revision (\S+), content-type (\S+), and body "(.+)"
    path = expand_vars(get_next_match(), vars)
    revision = expand_vars(get_next_match(), vars)
    ctype = expand_vars(get_next_match(), vars)
    body = unescape(expand_vars(get_next_match(), vars))
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
        'Revision': revision,
        'Content-Type': ctype,
    }
    vars['status_code'], vars['headers'], vars['body'] = put(
        vars['url'] + path, headers=headers, body=body)

    IMPLEMENTS WHEN client requests DELETE (/.+) with token
    path = get_next_match()
    path = expand_vars(path, vars)
    headers = {
        'Authorization': 'Bearer {}'.format(vars['token']),
    }
    vars['status_code'], vars['headers'], vars['body'] = delete(
        vars['url'] + path, headers=headers)

    IMPLEMENTS WHEN client uploads a fake jpg
    assert 0

## API access token creation

    IMPLEMENTS WHEN client gets an authorization token with scope "(.+)"
    scopes = get_next_match()
    print 'privkey', repr(vars['privkey'])
    assert vars['privkey']
    vars['token'] = create_token(vars['privkey'], vars['iss'], vars['aud'], scopes)

## UUID creation

    IMPLEMENTS GIVEN unique random identifier (\S+)
    import uuid
    name = get_next_match()
    vars[name] = str(uuid.uuid4())

## API request result checking

    IMPLEMENTS THEN HTTP status code is (\d+) (.*)
    expected = int(get_next_match())
    assertEqual(vars['status_code'], expected)

    IMPLEMENTS THEN HTTP (\S+) header is (.+)
    header = get_next_match()
    value = expand_vars(get_next_match(), vars)
    assertEqual(vars['headers'].get(header), value)

    IMPLEMENTS THEN remember HTTP (\S+) header as (.+)
    header = get_next_match()
    name = get_next_match()
    vars[name] = vars['headers'].get(header)

    IMPLEMENTS THEN resource id is (\S+)
    import json
    name = get_next_match()
    print 'body:', repr(vars['body'])
    body = json.loads(vars['body'])
    vars[name] = body['id']

    IMPLEMENTS THEN revision is (\S+)
    import json
    name = get_next_match()
    body = json.loads(vars['body'])
    vars[name] = body['revision']

    IMPLEMENTS THEN revisions (\S+) and (\S+) are different
    rev1 = get_next_match()
    rev2 = get_next_match()
    assertNotEqual(vars[rev1], vars[rev2])

    IMPLEMENTS THEN revisions (\S+) and (\S+) match
    rev1 = get_next_match()
    rev2 = get_next_match()
    assertEqual(vars[rev1], vars[rev2])

    IMPLEMENTS THEN JSON body matches (.+)
    import json
    wanted = get_next_match()
    print 'wanted1', repr(wanted)
    wanted = expand_vars(wanted, vars)
    print 'wanted2', repr(wanted)
    wanted = json.loads(wanted)
    actual = json.loads(vars['body'])
    print 'actual ', repr(actual)
    print 'wanted3', repr(wanted)
    assertTrue(values_match(wanted, actual))

    IMPLEMENTS THEN body is "(.+)"
    wanted = unescape(expand_vars(get_next_match(), vars))
    body = vars['body']
    assertTrue(values_match(wanted, body))

    IMPLEMENTS THEN search result contains (.+)
    import json
    wanted1 = get_next_match()
    wanted2 = expand_vars(wanted1, vars)
    wanted = json.loads(wanted2)
    actual = json.loads(vars['body'])
    print 'wanted1:', repr(wanted1)
    print 'wanted2:', repr(wanted2)
    print 'wanted:', repr(wanted)
    print 'actual:', repr(actual)
    assertTrue(actual['resources'])
    found = False
    for result in actual['resources']:
        if values_match(wanted, result):
            print 'MATCH!', repr(wanted), repr(result)
            found = True
            break
        print 'no match', repr(wanted), repr(result)
    assertTrue(found)

    IMPLEMENTS THEN search result does NOT contain (.+)
    import json
    wanted1 = get_next_match()
    wanted2 = expand_vars(wanted1, vars)
    wanted = json.loads(wanted2)
    actual = json.loads(vars['body'])
    print 'wanted1:', repr(wanted1)
    print 'wanted2:', repr(wanted2)
    print 'wanted:', repr(wanted)
    print 'actual:', repr(actual)
    found = False
    for result in actual['resources']:
        if values_match(wanted, result):
            found = True
    assertFalse(found)

    IMPLEMENTS THEN search result at index (\d+) has id (\S+)
    import json
    index = int(get_next_match())
    id_name = get_next_match()
    body = json.loads(vars['body'])
    print 'body', repr(body)
    resources = body['resources']
    print 'resources', repr(resources)
    print 'len resources', len(resources)
    print 'index', index
    assert index < len(resources)
    obj = resources[index]
    print 'resource at index', repr(obj)
    print 'id', repr(obj['id'])
    vars[id_name] = obj['id']

    IMPLEMENTS THEN search result has (\d+) resources
    wanted = int(get_next_match())
    body = json.loads(vars['body'])
    print 'body', repr(body)
    resources = body['resources']
    print 'resources', repr(resources)
    print 'len resources', len(resources)
    assertEqual(wanted, len(resources))

    IMPLEMENTS THEN response has header WWW-Authenticate containing "(.+)"
    assert 0
