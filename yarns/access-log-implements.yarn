# Step implementations for access log

This chapter shows the scenario step implementations for the
access log scenario.

    IMPLEMENTS GIVEN test client has id CLIENT
    vars['CLIENT'] = 'test_client'

    IMPLEMENTS GIVEN a running access log Qvarn instance
    start_qvarn('access', audience=vars['CLIENT'])

    IMPLEMENTS FINALLY access log Qvarn is stopped
    stop_qvarn('access')

    IMPLEMENTS GIVEN users A and B who can fully access person resources
    vars['scopes'] = ' '.join([
        'uapi_persons_get',
        'uapi_persons_post',
        'uapi_persons_id_get',
        'uapi_persons_id_put',
        'uapi_persons_id_delete',
        'uapi_persons_search_id_get',
        'uapi_access_get',
        'uapi_access_post',
        'uapi_access_id_get',
        'uapi_access_id_put',
        'uapi_access_id_delete',
        'uapi_access_search_id_get',
        'uapi_set_meta_fields',
    ])

    IMPLEMENTS GIVEN user A has person resource A_ID
    create_token_for_qvarn(vars['access'], vars['scopes'])
    person = {
        'names': ['User A'],
    }
    vars['status_code'], vars['headers'], vars['body'] = post_to_qvarn(
        vars['access'], '/persons', person)
    print vars['headers']
    print vars['body']
    vars['A_ID'] = json.loads(vars['body'])['id']

    IMPLEMENTS GIVEN user B has person resource B_ID
    create_token_for_qvarn(vars['access'], vars['scopes'])
    person = {
        'names': ['User B'],
    }
    vars['status_code'], vars['headers'], vars['body'] = post_to_qvarn(
        vars['access'], '/persons', person)
    vars['B_ID'] = json.loads(vars['body'])['id']

    IMPLEMENTS WHEN user A creates a person resource
    create_token_for_qvarn(
        vars['access'], vars['scopes'],
        'issuer', vars['A_ID'], vars['CLIENT'], True)
    person = {
        'names': ['New person created by A'],
    }
    vars['status_code'], vars['headers'], vars['body'] = post_to_qvarn(
        vars['access'], '/persons', person)

    IMPLEMENTS THEN access log contains only one entry
    create_token_for_qvarn(vars['access'], vars['scopes'])
    get_from_qvarn(
        vars['access'],
        '/access/search/exact/resource_id/{}'.format(vars['ID']))
    assertEqual(vars['status_code'], 200)
    logs = json.loads(vars['body'])['resources']
    assertEqual(len(logs), 1)

    IMPLEMENTS THEN access log contains entry (.+)
    create_token_for_qvarn(vars['access'], vars['scopes'])
    expected = json.loads(expand_vars(get_next_match(), vars))
    get_from_qvarn(
        vars['access'],
        '/access/search/show_all/exact/resource_id/{}'.format(vars['ID']))
    assertEqual(vars['status_code'], 200)
    logs = json.loads(vars['body'])['resources']
    filtered_logs = [{k: l[k] for k in expected.keys()} for l in logs]
    assertIn(expected, filtered_logs)

    IMPLEMENTS WHEN user B requests GET (/.+), with header (.+): (.+)
    create_token_for_qvarn(
        vars['access'], vars['scopes'],
        'issuer', vars['B_ID'], vars['CLIENT'], True)
    path = expand_vars(get_next_match(), vars)
    header_key = get_next_match()
    header_value = get_next_match()
    get_from_qvarn(vars['access'], path, {header_key: header_value})

    IMPLEMENTS WHEN user A updates (/.+) without changing it
    create_token_for_qvarn(
        vars['access'], vars['scopes'],
        'issuer', vars['A_ID'], vars['CLIENT'], True)
    path = expand_vars(get_next_match(), vars)
    person = get_from_qvarn(vars['access'], path)
    vars['status_code'], vars['headers'], vars['body'] = put_to_qvarn(
        vars['access'], path, person)
    # vars['REV2'] = json.loads(vars['body'])['revision']

    IMPLEMENTS WHEN user A deletes (/.+)
    create_token_for_qvarn(
        vars['access'], vars['scopes'],
        'issuer', vars['A_ID'], vars['CLIENT'], True)
    path = expand_vars(get_next_match(), vars)
    delete_from_qvarn(vars['access'], path)
    assertEqual(vars['status_code'], 200)
    get_from_qvarn(vars['access'], path)
    assertEqual(vars['status_code'], 404)

    IMPLEMENTS WHEN test client requests GET (/.+), with header (.+)
    create_token_for_qvarn(
        vars['access'], vars['scopes'], 'issuer', '', vars['CLIENT'], True)
    path = expand_vars(get_next_match(), vars)
    header = get_next_match()
    header_dict = {}
    for h in re.findall('[a-zA-Z-]+: .+?(?=(?: [a-zA-Z-]+: )|\Z)', header):
        key, value = h.split(': ', 1)
        header_dict[key] = value
    get_from_qvarn(vars['access'], path, header_dict)

    IMPLEMENTS WHEN access log can be listed
    create_token_for_qvarn(vars['access'], vars['scopes'])
    get_from_qvarn(vars['access'], '/access')
    assertEqual(vars['status_code'], 200)

    IMPLEMENTS WHEN there is an entry (.+) in access log
    create_token_for_qvarn(vars['access'], vars['scopes'])
    get_from_qvarn(vars['access'], '/access/search/show_all')
    assertEqual(vars['status_code'], 200)
    logs = json.loads(vars['body'])['resources']
    assertGreaterThan(len(logs), 0)
    vars[get_next_match()] = logs[0]

    IMPLEMENTS THEN access log entry cannot be added, with body (.+)
    create_token_for_qvarn(vars['access'], vars['scopes'])
    entry = json.loads(expand_vars(get_next_match(), vars))
    vars['status_code'], vars['headers'], vars['body'] = post_to_qvarn(
        vars['access'], '/access', entry)
    assertEqual(vars['status_code'], 405)

    IMPLEMENTS THEN access log entry (.+) cannot be updated
    create_token_for_qvarn(vars['access'], vars['scopes'])
    entry = vars[get_next_match()]
    vars['status_code'], vars['headers'], vars['body'] = put_to_qvarn(
        vars['access'], '/access/{}'.format(entry['id']), entry)
    assertEqual(vars['status_code'], 405)

    IMPLEMENTS WHEN new access log entries are generated
    create_token_for_qvarn(vars['access'], vars['scopes'])
    time.sleep(2)
    vars['status_code'], vars['headers'], vars['body'] = post_to_qvarn(
        vars['access'], '/persons', {'names': ['Person']})

    IMPLEMENTS WHEN user deletes old entries with access log tool
    create_token_for_qvarn(vars['access'], vars['scopes'])
    delete_access(vars['access'], 1)

    IMPLEMENTS THEN no old access log entries are found
    get_from_qvarn(vars['access'], '/access')
    assertEqual(vars['status_code'], 200)
    logs = json.loads(vars['body'])['resources']
    assertEqual(len(logs), 1)
