---
title: qvarn2 integration tests
...


# Introduction

This is an integration test suite for the Qvarn HTTP API.

# Version checking

    SCENARIO Qvarn reports its version

    GIVEN a running qvarn instance

    WHEN client requests GET /version without token
    THEN HTTP status code is 200 OK

    WHEN client gets an authorization token with scope "uapi_version_get"
    AND client requests GET /version using token
    THEN HTTP status code is 200 OK

    FINALLY qvarn is stopped


# Manage a subject

    SCENARIO user manages a subject resource

    GIVEN a running Qvarn instance

    WHEN client requests GET /subjects without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client requests GET /subjects/notexist without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client gets an authorization token with scope 
    ... "uapi_subjects_get uapi_subjects_post uapi_subjects_id_get 
    ...  uapi_subjects_id_put uapi_subjects_id_delete"
    AND client requests GET /subjects using token
    THEN HTTP status code is 200 OK

    WHEN client requests GET /subjects using  token
    THEN HTTP status code is 200 OK
    AND search result does NOT contain { "id": "subject" }

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [
    ...         { "full_name": "Jason Bourne" }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    AND resource id is ID1
    AND revision is REV1

    WHEN client requests GET /subjects/${ID1} without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... { "revision": "${REV1}", "id": "${ID1}", "type": "subject",
    ...   "names": [{ "full_name": "Jason Bourne" }] }

For silly hysterical raisins, the Qvarn API is defined to return 400
if updating a resource with the wrong revision in the body, instead
of 404. We may want to fix this some day.

    WHEN client requests PUT /subjects/${ID1} with token and body
    ... { "id": "wrong", "revision": "${REV1}", "names": [{"full_name": "Dave Webb"}]}
    THEN HTTP status code is 400 Bad

    WHEN client requests PUT /subjects/${ID1} with token and body
    ... { "id": "${ID1}", "revision": "${REV1}", "names": [{"full_name": "Dave Webb"}]}
    THEN HTTP status code is 200 OK
    AND revision is REV2

    WHEN client requests PUT /subjects/${ID1} with token and body
    ... { "type": "subject", "id": "${ID1}", "revision": "${REV2}",
    ...   "names": [{"full_name": "David Webb" }]}
    THEN HTTP status code is 200 OK
    AND revision is REV3

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... { "revision": "${REV3}", "id": "${ID1}", "type": "subject",
    ...   "names": [{"full_name": "David Webb" }]}

    WHEN client requests DELETE /subjects/${ID1} with token
    THEN HTTP status code is 200 OK

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 404 Not Found

    FINALLY qvarn is stopped


# Manage notifications

Notifications are a special resource type. Notifications created
automatically by Qvarn, but the API client may delete them.

    SCENARIO manage notifications

    GIVEN a running Qvarn instance

Client has needed access rights for orgs resource.

    WHEN client gets an authorization token with scope
    ... "uapi_orgs_listeners_post uapi_orgs_listeners_id_get
    ...  uapi_orgs_listeners_get uapi_orgs_listeners_id_notifications_get
    ...  uapi_orgs_post uapi_orgs_listeners_id_notifications_id_get
    ...  uapi_orgs_listeners_id_put uapi_orgs_id_put uapi_orgs_id_delete
    ...  uapi_orgs_listeners_id_delete
    ...  uapi_orgs_listeners_id_notifications_id_delete"

    WHEN client requests POST /orgs/listeners with token and body
    ... {
    ...     "notify_of_new": true
    ... }
    THEN HTTP status code is 201 Created
    AND JSON body matches
    ... {
    ...     "type": "listener",
    ...     "notify_of_new": true,
    ...     "listen_on": []
    ... }
    AND resource id is LISTENID1
    AND HTTP Location header is ${API_URL}/orgs/listeners/${LISTENID1}

    WHEN client requests POST /orgs/listeners with token and body
    ... {
    ...     "notify_of_new": false
    ... }
    THEN HTTP status code is 201 Created
    AND JSON body matches
    ... {
    ...     "type": "listener",
    ...     "notify_of_new": false,
    ...     "listen_on": []
    ... }
    AND resource id is LISTENID2
    AND HTTP Location header is ${API_URL}/orgs/listeners/${LISTENID2}
    AND revision is REV1

    WHEN client requests POST /orgs/listeners with token and body
    ... {
    ...     "notify_of_new": false,
    ...     "listen_on_all": true
    ... }
    THEN HTTP status code is 201 Created
    AND JSON body matches
    ... {
    ...     "type": "listener",
    ...     "notify_of_new": false,
    ...     "listen_on_all": true,
    ...     "listen_on": []
    ... }
    AND resource id is LISTENID3
    AND HTTP Location header is ${API_URL}/orgs/listeners/${LISTENID3}

    WHEN client requests GET /orgs/listeners/${LISTENID1} using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "id": "${LISTENID1}",
    ...     "type": "listener",
    ...     "notify_of_new": true,
    ...     "listen_on": []
    ... }

    WHEN client requests GET /orgs/listeners using token
    THEN HTTP status code is 200 OK
    THEN search result contains  {"id": "${LISTENID1}"}
    THEN search result contains  {"id": "${LISTENID2}"}

A listener has no notifications initially.

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID1}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": []
    ... }

    WHEN client requests POST /orgs with token and body
    ... {
    ...     "names": ["Universal Exports"]
    ... }
    THEN resource id is ORGID1
    AND revision is REV2

    WHEN client requests POST /orgs with token and body
    ... {
    ...     "names": ["Telebulvania Ltd"]
    ... }
    THEN resource id is ORGID2

After adding the new organizations the first listener should be notified while
the second and third should have no notifications.

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID1}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND search result at index 0 has id MSGID1
    AND search result at index 1 has id MSGID1

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID1}/notifications/${MSGID1}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID1}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID1}",
    ...     "resource_change": "created"
    ... }

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID1}/notifications/${MSGID2}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID2}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID2}",
    ...     "resource_change": "created"
    ... }

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID2}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": []
    ... }

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID3}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": []
    ... }

We update the empty listener to listen on organization changes and update the
organization checking for the correct notification to appear. The third
listener listening to all the changes should get the notification, too.

    WHEN client requests PUT /orgs/listeners/${LISTENID2} with token and body
    ... {
    ...     "notify_of_new": false,
    ...     "listen_on": ["${ORGID1}"],
    ...     "revision": "${REV1}"
    ... }
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "type": "listener",
    ...     "notify_of_new": false,
    ...     "listen_on": ["${ORGID1}"]
    ... }

    WHEN client requests PUT /orgs/${ORGID1} with token and body
    ... {
    ...     "names": ["Universal Experts"],
    ...     "revision": "${REV2}"
    ... }
    THEN HTTP status code is 200 OK

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID2}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND search result at index 0 has id MSGID3

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID2}/notifications/${MSGID3}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID3}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID1}",
    ...     "resource_change": "updated"
    ... }

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID3}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND search result at index 0 has id MSGID4

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID3}/notifications/${MSGID4}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID4}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID1}",
    ...     "resource_change": "updated"
    ... }

The first listener gets no additional notifications.

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID1}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${MSGID1}"}, {"id": "${MSGID2}"}
    ...     ]
    ... }

We delete the organization and check for the correct notification to appear.

    WHEN client requests DELETE /orgs/${ORGID1} with token
    THEN HTTP status code is 200 OK

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID2}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND search result at index 1 has id MSGID5

    WHEN client requests 
    ... GET /orgs/listeners/${LISTENID2}/notifications/${MSGID5}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID5}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID1}",
    ...     "resource_revision": null,
    ...     "resource_change": "deleted"
    ... }

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID3}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND search result at index 1 has id MSGID6

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID3}/notifications/${MSGID6}
    ... using token
    THEN JSON body matches
    ... {
    ...     "id": "${MSGID6}",
    ...     "type": "notification",
    ...     "resource_id": "${ORGID1}",
    ...     "resource_revision": null,
    ...     "resource_change": "deleted"
    ... }

The first listener gets no additional notifications.

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID1}/notifications
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${MSGID1}"}, {"id": "${MSGID2}"}
    ...     ]
    ... }

Deletion of a listener deletes also the notifications.

    WHEN client requests DELETE /orgs/listeners/${LISTENID1} with token
    THEN HTTP status code is 200 OK

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID1}/notifications/${MSGID1}
    ... using token
    THEN HTTP status code is 404 Not Found

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID1}/notifications/${MSGID2}
    ... using token
    THEN HTTP status code is 404 Not Found

    WHEN client requests GET /orgs/listeners/${LISTENID1} using token
    THEN HTTP status code is 404 Not Found

Notification can be deleted.

    WHEN client requests 
    ... DELETE /orgs/listeners/${LISTENID2}/notifications/${MSGID3}
    ... with token
    THEN HTTP status code is 200 OK

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID2}/notifications/${MSGID3}
    ... using token
    THEN HTTP status code is 404 Not Found

    WHEN client requests
    ... DELETE /orgs/listeners/${LISTENID3}/notifications/${MSGID4}
    ... with token
    THEN HTTP status code is 200 OK

    WHEN client requests
    ... GET /orgs/listeners/${LISTENID3}/notifications/${MSGID4}
    ... using token
    THEN HTTP status code is 404 Not Found

    WHEN client requests
    ... DELETE /orgs/listeners/${LISTENID2}/notifications/${MSGID5}
    ... with token
    THEN HTTP status code is 200 OK

    WHEN client requests
    ... DELETE /orgs/listeners/${LISTENID3}/notifications/${MSGID6}
    ... with token
    THEN HTTP status code is 200 OK


    FINALLY qvarn is stopped

# Use subresources

Subresources are additional resources that are attached to a resource,
and be managed and access controlled separetly. However, they share
existence and revision with their parent: if the parent is deleted, so
is the subresource, and if either the parent or the subresource is
changed, and gets a new revision, so does the other.

Subresources always exist, if defined in the resource type spec. They
don't need to be created specially.

    SCENARIO manage subresources

    GIVEN a running qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_sub_put uapi_subjects_sub_get"

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Alfred" } ] }
    THEN resource id is ID
    AND revision is REV

    WHEN client requests GET /subjects/${ID}/sub using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "subfield": ""
    ... }

    WHEN client requests PUT /subjects/${ID}/sub with token and body
    ... {
    ...     "revision": "wrong",
    ...     "subfield": "Steven Segal"
    ... }
    THEN HTTP status code is 409 Conflict

    WHEN client requests PUT /subjects/${ID}/sub with token and body
    ... {
    ...     "revision": "${REV}",
    ...     "subfield": "Steven Segal"
    ... }
    THEN HTTP status code is 200 OK
    AND revision is REV2
    AND JSON body matches
    ... {
    ...     "revision": "${REV2}",
    ...     "subfield": "Steven Segal"
    ... }

    FINALLY qvarn is stopped



# Search subjects

    SCENARIO search subjects

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope 
    ... "uapi_subjects_post uapi_subjects_search_id_get
    ...  uapi_subjects_id_delete"

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Alfred" } ] }
    THEN resource id is ID1
    AND revision is REV1

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Alfred" } ] }
    THEN resource id is ID2

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Bruce" } ] }
    THEN resource id is ID3

    WHEN client requests GET /subjects/search/exact/full_name/Batman
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches { "resources": []}

Make sure searches are case-insensitive.

    WHEN client requests GET /subjects/search/exact/full_name/ALFRED
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests GET /subjects/search/exact/full_name/bruce
    ... using token
    THEN HTTP status code is 200 OK
    AND search result does NOT contain {"id": "${ID1}"}
    AND search result does NOT contain {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}
    AND JSON body matches { "resources": [{"id": "${ID3}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/fred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/gt/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result does NOT contain {"id": "${ID1}"}
    AND search result does NOT contain {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/ge/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/startswith/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/show/full_name/contains/full_name/fred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/show_all/exact/full_name/Bruce
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains
    ... {
    ...     "id": "${ID3}",
    ...     "names": [ { "full_name": "Bruce" } ]
    ... }

    WHEN client requests
    ... GET /subjects/search/exact/full_name/Br%2Fce
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches { "resources": [] }

    GIVEN unique random identifier RANDOM
    WHEN client requests PUT /subjects/${ID1}/sub with token and body
    ... { "subfield": "${RANDOM}", "revision": "${REV1}" }
    THEN HTTP status code is 200 OK

    WHEN client requests GET /subjects/search/exact/subfield/${RANDOM} using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}

    FINALLY qvarn is stopped


# More search

This scenario creates two resources, and searches with two conditions.
Each condition matches a resource, but the two match different ones.
Thus the result should be an empty set.

    SCENARIO search with two conditions when two resources match one

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get
    ...  uapi_subjects_id_delete"

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [{
    ...         "full_name": "Clark Kent",
    ...         "sort_key": "Clark the superman"
    ...     }]
    ... }
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [{
    ...         "full_name": "Clark Celt",
    ...         "sort_key": "a nobody"
    ...     }]
    ... }
    THEN resource id is ID2

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Kent/contains/sort_key/nobody
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches { "resources": [ ]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Clark
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {"resources": [{"id": "${ID1}"}, {"id": "${ID2}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Kent
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches {"resources": [{"id": "${ID1}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/sort_key/nobody
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches {"resources": [{"id": "${ID2}"}]}

    FINALLY qvarn is stopped

# Searching with multiple conditions

    SCENARIO search with multiple conditions

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_contracts_post uapi_contracts_search_id_get"

Create an organisation, a person and an employment contract between them.

    WHEN client requests POST /contracts with token and body
    ... {"contract_type": "employment",
    ... "start_date": "2016-01-01",
    ... "contract_parties": [
    ...     {
    ...         "type": "org",
    ...         "resource_id": "org-1",
    ...         "role": "employer"
    ...     },
    ...     {
    ...         "type": "person",
    ...         "resource_id": "person-1",
    ...         "role": "employee"
    ...     }
    ... ],
    ... "contract_state": "active"
    ... }
    THEN HTTP status code is 201 Created
    AND resource id is CONTRACT_ID1

Perform searches matching different instances of the same nested element.

    WHEN client requests
    ... GET /contracts/search/exact/resource_id/org-1/exact/resource_id/person-1
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${CONTRACT_ID1}"}

    WHEN client requests
    ... GET /contracts/search/exact/resource_id/org-1/exact/resource_id/wrong_id
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": []
    ... }

    FINALLY qvarn is stopped

# Sort search results

    SCENARIO search with sort

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get"

Create several person resources.

    GIVEN unique random identifier UID

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person A",
    ...             "sort_key": "3, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "A"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID3

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person B",
    ...             "sort_key": "1, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "B"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person C",
    ...             "sort_key": "2, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "C"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID2

Search person resources and sort results by `sort_key`.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/sort_key 
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"},
    ...         {"id": "${ID3}"}
    ...     ]
    ... }

Sort person resources using different sort key.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID3}"},
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"}
    ...     ]
    ... }

Search person resources and sort results by two search keys, where first search
key is a list containing more than one value. First key is `surnames`, where
each resource has same first surname, and second key is `sort_key`. Since each
first surname is the same, results should fall back to the second sort key.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/surnames/sort/sort_key
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"},
    ...         {"id": "${ID3}"}
    ...     ]
    ... }

Search with only search operator should also work, returning all available
resource ids.

    WHEN client requests
    ... GET /subjects/search/sort/sort_key
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    FINALLY qvarn is stopped

# Sort search results with /offset and /limit

    SCENARIO search with /offset and /limit

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get"

Create several person resources.

    GIVEN unique random identifier UID

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 1"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 2"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID2

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 3"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID3

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 4"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID4

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 5"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID5

Sort, return first two hits.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"}
    ...     ]
    ... }

Sort, return second set of two hits.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/offset/2/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID3}"},
    ...         {"id": "${ID4}"}
    ...     ]
    ... }

Sort, return third set of two hits, which is actualy only one item.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/offset/4/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID5}"}
    ...     ]
    ... }

Don't sort. Then /offset and /limit are verboten.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/offset/1
    ... using token
    THEN HTTP status code is 400 Error
    AND JSON body matches
    ... {
    ...   "message": "LIMIT and OFFSET can only be used with together SORT.",
    ...   "error_code": "LimitWithoutSortError"
    ... }

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/offset/1
    ... using token
    THEN HTTP status code is 400 Error
    AND JSON body matches
    ... {
    ...   "message": "LIMIT and OFFSET can only be used with together SORT.",
    ...   "error_code": "LimitWithoutSortError"
    ... }

    FINALLY qvarn is stopped


# Handle resource types via API

Qvarn API allows listing and looking at all the resource types it
knows about. In the future, it will allow manipulaing them as well.

    SCENARIO manage resource types

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_resource_types_get uapi_resource_types_id_get"

    WHEN client requests GET /resource_types using token
    THEN HTTP status code is 200 OK
    AND search result contains { "id": "subject" }

    WHEN client requests GET /resource_types/subject using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "id": "subject",
    ...     "type": "resource_type",
    ...     "path": "/subjects"
    ... }

    FINALLY qvarn is stopped
