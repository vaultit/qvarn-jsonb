---
title: qvarn2 integration tests
...


# Introduction

This is an integration test suite for the Qvarn HTTP API.

# Version checking

    SCENARIO Qvarn reports its version

    GIVEN a running qvarn instance

    WHEN client requests GET /version without token
    THEN HTTP status code is 200 OK

    WHEN client gets an authorization token with scope "uapi_version_get"
    AND client requests GET /version using token
    THEN HTTP status code is 200 OK

    FINALLY qvarn is stopped


# Manage a subject

    SCENARIO user manages a subject resource

    GIVEN a running Qvarn instance

    WHEN client requests GET /subjects without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client requests GET /subjects/notexist without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client gets an authorization token with scope 
    ... "uapi_subjects_get uapi_subjects_post uapi_subjects_id_get 
    ...  uapi_subjects_id_put uapi_subjects_id_delete"
    AND client requests GET /subjects using token
    THEN HTTP status code is 200 OK

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [
    ...         { "full_name": "Jason Bourne" }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    AND resource id is ID1
    AND revision is REV1

    WHEN client requests GET /subjects/${ID1} without token
    THEN HTTP status code is 401 Unauthorized

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... { "revision": "${REV1}", "id": "${ID1}", "type": "subject",
    ...   "names": [{ "full_name": "Jason Bourne" }] }

    WHEN client requests PUT /subjects/${ID1} with token and body
    ... { "id": "${ID1}", "revision": "${REV1}", "names": [{"full_name": "Dave Webb"}]}
    THEN HTTP status code is 200 OK
    AND revision is REV2

    WHEN client requests PUT /subjects/${ID1} with token and body
    ... { "type": "subject", "id": "${ID1}", "revision": "${REV2}",
    ...   "names": [{"full_name": "David Webb" }]}
    THEN HTTP status code is 200 OK
    AND revision is REV3

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... { "revision": "${REV3}", "id": "${ID1}", "type": "subject",
    ...   "names": [{"full_name": "David Webb" }]}

    WHEN client requests DELETE /subjects/${ID1} with token
    THEN HTTP status code is 200 OK

    WHEN client requests GET /subjects/${ID1} using token
    THEN HTTP status code is 404 Not Found

    FINALLY qvarn is stopped

# Search subjects

    SCENARIO search subjects

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope 
    ... "uapi_subjects_post uapi_subjects_search_id_get
    ...  uapi_subjects_id_delete"

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Alfred" } ] }
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Alfred" } ] }
    THEN resource id is ID2

    WHEN client requests POST /subjects with token and body
    ... { "type": "subject", "names": [ { "full_name": "Bruce" } ] }
    THEN resource id is ID3

    WHEN client requests GET /subjects/search/exact/full_name/Batman
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches { "resources": []}

    WHEN client requests GET /subjects/search/exact/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests GET /subjects/search/exact/full_name/Bruce
    ... using token
    THEN HTTP status code is 200 OK
    AND search result does NOT contain {"id": "${ID1}"}
    AND search result does NOT contain {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}
    AND JSON body matches { "resources": [{"id": "${ID3}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/fred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/gt/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result does NOT contain {"id": "${ID1}"}
    AND search result does NOT contain {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/ge/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/startswith/full_name/Alfred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/show/full_name/contains/full_name/fred
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result does NOT contain {"id": "${ID3}"}

    WHEN client requests
    ... GET /subjects/search/show_all/exact/full_name/Bruce
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains
    ... {
    ...     "id": "${ID3}",
    ...     "names": [ { "full_name": "Bruce" } ]
    ... }

    FINALLY qvarn is stopped


# More search

This scenario creates two resources, and searches with two conditions.
Each condition matches a resource, but the two match different ones.
Thus the result should be an empty set.

    SCENARIO search with two conditions when two resources match one

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get
    ...  uapi_subjects_id_delete"

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [{
    ...         "full_name": "Clark Kent",
    ...         "sort_key": "Clark the superman"
    ...     }]
    ... }
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "type": "subject",
    ...     "names": [{
    ...         "full_name": "Clark Celt",
    ...         "sort_key": "a nobody"
    ...     }]
    ... }
    THEN resource id is ID2

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Kent/contains/sort_key/nobody
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches { "resources": [ ]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Clark
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {"resources": [{"id": "${ID1}"}, {"id": "${ID2}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/full_name/Kent
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches {"resources": [{"id": "${ID1}"}]}

    WHEN client requests
    ... GET /subjects/search/contains/sort_key/nobody
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches {"resources": [{"id": "${ID2}"}]}

    FINALLY qvarn is stopped

# Searching with multiple conditions

    SCENARIO search with multiple conditions

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_contracts_post uapi_contracts_search_id_get"

Create an organisation, a person and an employment contract between them.

    WHEN client requests POST /contracts with token and body
    ... {"contract_type": "employment",
    ... "start_date": "2016-01-01",
    ... "contract_parties": [
    ...     {
    ...         "type": "org",
    ...         "resource_id": "org-1",
    ...         "role": "employer"
    ...     },
    ...     {
    ...         "type": "person",
    ...         "resource_id": "person-1",
    ...         "role": "employee"
    ...     }
    ... ],
    ... "contract_state": "active"
    ... }
    THEN HTTP status code is 201 Created
    AND resource id is CONTRACT_ID1

Perform searches matching different instances of the same nested element.

    WHEN client requests
    ... GET /contracts/search/exact/resource_id/org-1/exact/resource_id/person-1
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${CONTRACT_ID1}"}

    WHEN client requests
    ... GET /contracts/search/exact/resource_id/org-1/exact/resource_id/wrong_id
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": []
    ... }

    FINALLY qvarn is stopped

# Sort search results

    SCENARIO search with sort

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get"

Create several person resources.

    GIVEN unique random identifier UID

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person A",
    ...             "sort_key": "3, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "A"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID3

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person B",
    ...             "sort_key": "1, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "B"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person C",
    ...             "sort_key": "2, Person",
    ...             "given_names": ["Test"],
    ...             "surnames": ["Person", "C"]
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID2

Search person resources and sort results by `sort_key`.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/sort_key 
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"},
    ...         {"id": "${ID3}"}
    ...     ]
    ... }

Sort person resources using different sort key.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID3}"},
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"}
    ...     ]
    ... }

Search person resources and sort results by two search keys, where first search
key is a list containing more than one value. First key is `surnames`, where
each resource has same first surname, and second key is `sort_key`. Since each
first surname is the same, results should fall back to the second sort key.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/surnames/sort/sort_key
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"},
    ...         {"id": "${ID3}"}
    ...     ]
    ... }

Search with only search operator should also work, returning all available
resource ids.

    WHEN client requests
    ... GET /subjects/search/sort/sort_key
    ... using token
    THEN HTTP status code is 200 OK
    AND search result contains {"id": "${ID1}"}
    AND search result contains {"id": "${ID2}"}
    AND search result contains {"id": "${ID3}"}

    FINALLY qvarn is stopped

# Sort search results with /offset and /limit

    SCENARIO search with /offset and /limit

    GIVEN a running Qvarn instance

    WHEN client gets an authorization token with scope
    ... "uapi_subjects_post uapi_subjects_search_id_get"

Create several person resources.

    GIVEN unique random identifier UID

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 1"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID1

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 2"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID2

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 3"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID3

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 4"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID4

    WHEN client requests POST /subjects with token and body
    ... {
    ...     "random_id": "${UID}",
    ...     "names": [
    ...         {
    ...             "full_name": "Person 5"
    ...         }
    ...     ]
    ... }
    THEN HTTP status code is 201 Created
    THEN resource id is ID5

Sort, return first two hits.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID1}"},
    ...         {"id": "${ID2}"}
    ...     ]
    ... }

Sort, return second set of two hits.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/offset/2/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID3}"},
    ...         {"id": "${ID4}"}
    ...     ]
    ... }

Sort, return third set of two hits, which is actualy only one item.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/sort/full_name/offset/4/limit/2
    ... using token
    THEN HTTP status code is 200 OK
    AND JSON body matches
    ... {
    ...     "resources": [
    ...         {"id": "${ID5}"}
    ...     ]
    ... }

Don't sort. Then /offset and /limit are verboten.

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/offset/1
    ... using token
    THEN HTTP status code is 400 Error
    AND JSON body matches
    ... {
    ...   "message": "LIMIT and OFFSET can only be used with together SORT.",
    ...   "error_code": "LimitWithoutSortError"
    ... }

    WHEN client requests
    ... GET /subjects/search/exact/random_id/${UID}/offset/1
    ... using token
    THEN HTTP status code is 400 Error
    AND JSON body matches
    ... {
    ...   "message": "LIMIT and OFFSET can only be used with together SORT.",
    ...   "error_code": "LimitWithoutSortError"
    ... }

    FINALLY qvarn is stopped
